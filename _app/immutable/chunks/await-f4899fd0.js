import{S,i as L,s as M,C as y,w as R,x as T,y as j,z as C,A as x,f as q,t as z,B,N as $,l as f,r as N,a as v,m as d,n as h,u as D,h as n,c as w,p as g,b as m,H as F,E as G}from"./index-37ae0623.js";import{S as I}from"./Section-6b20cdf8.js";import"./index-05d60d5f.js";import"./Tutorial-0c4825ec.js";function J(u){let e,o,r,l,t=`<code class="language-html">&#123;#await promise&#125;
	<span class="token comment">&lt;!-- promise is pending --></span>	
&#123;:then value&#125;
	<span class="token comment">&lt;!-- promise was fulfilled --></span>	
&#123;:catch error&#125;
	<span class="token comment">&lt;!-- promise was rejected --></span>	
&#123;/await&#125;</code>`,s,i,E=`<code class="language-html">&#123;#await promise then value&#125;
	<span class="token comment">&lt;!-- pending state doesn't matter --></span>	
&#123;/await&#125;</code>`,_,p,b=`<code class="language-html">&#123;#await promise catch error&#125;
	<span class="token comment">&lt;!-- only an error should be handled --></span>	
&#123;/await&#125;</code>`;return{c(){e=f("p"),o=N("Await the value of promises directly in your markup"),r=v(),l=f("pre"),s=v(),i=f("pre"),_=v(),p=f("pre"),this.h()},l(a){e=d(a,"P",{});var c=h(e);o=D(c,"Await the value of promises directly in your markup"),c.forEach(n),r=w(a),l=d(a,"PRE",{class:!0});var A=h(l);A.forEach(n),s=w(a),i=d(a,"PRE",{class:!0});var H=h(i);H.forEach(n),_=w(a),p=d(a,"PRE",{class:!0});var P=h(p);P.forEach(n),this.h()},h(){g(l,"class","language-html"),g(i,"class","language-html"),g(p,"class","language-html")},m(a,c){m(a,e,c),F(e,o),m(a,r,c),m(a,l,c),l.innerHTML=t,m(a,s,c),m(a,i,c),i.innerHTML=E,m(a,_,c),m(a,p,c),p.innerHTML=b},p:G,d(a){a&&n(e),a&&n(r),a&&n(l),a&&n(s),a&&n(i),a&&n(_),a&&n(p)}}}function K(u){let e,o;const r=[u[0],k];let l={$$slots:{default:[J]},$$scope:{ctx:u}};for(let t=0;t<r.length;t+=1)l=y(l,r[t]);return e=new I({props:l}),{c(){R(e.$$.fragment)},l(t){T(e.$$.fragment,t)},m(t,s){j(e,t,s),o=!0},p(t,[s]){const i=s&1?C(r,[s&1&&x(t[0]),s&0&&x(k)]):{};s&2&&(i.$$scope={dirty:s,ctx:t}),e.$set(i)},i(t){o||(q(e.$$.fragment,t),o=!0)},o(t){z(e.$$.fragment,t),o=!1},d(t){B(e,t)}}}const k={layout:"section",id:"await",h:"{#await ...}",docs:"https://svelte.dev/docs#template-syntax-await",tutorials:["https://svelte.dev/tutorial/await-blocks"]};function O(u,e,o){return u.$$set=r=>{o(0,e=y(y({},e),$(r)))},e=$(e),[e]}class X extends S{constructor(e){super(),L(this,e,O,K,M,{})}}export{X as default,k as metadata};
