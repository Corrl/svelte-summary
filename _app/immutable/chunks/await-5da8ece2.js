import{S,i as L,s as M,C as y,w as R,x as T,y as j,z as q,A as x,q as C,o as z,B,N as k,e as f,t as N,k as v,c as d,a as h,h as D,d as n,m as w,b as g,g as p,H as F,E as G}from"./index-26167588.js";import{S as I}from"./Section-6b147be5.js";import"./index-6967b286.js";import"./Tutorial-ee6e922e.js";function J(u){let e,o,r,l,t=`<code class="language-html">&#123;#await promise&#125;
	<span class="token comment">&lt;!-- promise is pending --></span>	
&#123;:then value&#125;
	<span class="token comment">&lt;!-- promise was fulfilled --></span>	
&#123;:catch error&#125;
	<span class="token comment">&lt;!-- promise was rejected --></span>	
&#123;/await&#125;</code>`,s,i,E=`<code class="language-html">&#123;#await promise then value&#125;
	<span class="token comment">&lt;!-- pending state doesn't matter --></span>	
&#123;/await&#125;</code>`,_,m,b=`<code class="language-html">&#123;#await promise catch error&#125;
	<span class="token comment">&lt;!-- only an error should be handled --></span>	
&#123;/await&#125;</code>`;return{c(){e=f("p"),o=N("Await the value of promises directly in your markup"),r=v(),l=f("pre"),s=v(),i=f("pre"),_=v(),m=f("pre"),this.h()},l(a){e=d(a,"P",{});var c=h(e);o=D(c,"Await the value of promises directly in your markup"),c.forEach(n),r=w(a),l=d(a,"PRE",{class:!0});var A=h(l);A.forEach(n),s=w(a),i=d(a,"PRE",{class:!0});var H=h(i);H.forEach(n),_=w(a),m=d(a,"PRE",{class:!0});var P=h(m);P.forEach(n),this.h()},h(){g(l,"class","language-html"),g(i,"class","language-html"),g(m,"class","language-html")},m(a,c){p(a,e,c),F(e,o),p(a,r,c),p(a,l,c),l.innerHTML=t,p(a,s,c),p(a,i,c),i.innerHTML=E,p(a,_,c),p(a,m,c),m.innerHTML=b},p:G,d(a){a&&n(e),a&&n(r),a&&n(l),a&&n(s),a&&n(i),a&&n(_),a&&n(m)}}}function K(u){let e,o;const r=[u[0],$];let l={$$slots:{default:[J]},$$scope:{ctx:u}};for(let t=0;t<r.length;t+=1)l=y(l,r[t]);return e=new I({props:l}),{c(){R(e.$$.fragment)},l(t){T(e.$$.fragment,t)},m(t,s){j(e,t,s),o=!0},p(t,[s]){const i=s&1?q(r,[s&1&&x(t[0]),s&0&&x($)]):{};s&2&&(i.$$scope={dirty:s,ctx:t}),e.$set(i)},i(t){o||(C(e.$$.fragment,t),o=!0)},o(t){z(e.$$.fragment,t),o=!1},d(t){B(e,t)}}}const $={layout:"section",id:"await",h:"{#await ...}",docs:"https://svelte.dev/docs#template-syntax-await",tutorials:["https://svelte.dev/tutorial/await-blocks"]};function O(u,e,o){return u.$$set=r=>{o(0,e=y(y({},e),k(r)))},e=k(e),[e]}class X extends S{constructor(e){super(),L(this,e,O,K,M,{})}}export{X as default,$ as metadata};
